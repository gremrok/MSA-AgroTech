### <a name="_b7urdng99y53"></a>**Название: Детализация компонентов и выбор технологий реализации**
### <a name="_hjk0fkfyohdk"></a>**Автор: Терехин Алексей**
### <a name="_uanumrh8zrui"></a>**Дата: 27.12.2025**

### Проблема или возможность
После выбора доменно-ориентированной декомпозиции необходимо детализировать внутреннюю структуру ключевых сервисов, выбрать конкретные технологии реализации и определить паттерны взаимодействия между компонентами.

### Решение и обоснование
1. Animal Health Service - Python (Django)
Выбор стека: Python + Django + Celery + Redis

    Обоснование:

    - Быстрая разработка: Django Admin для CRUD операций с ветеринарными записями
    - ML интеграция: Широкая экосистема Python для машинного обучения
    - Асинхронность: Celery для обработки ресурсоемких анализов

    Компромисс: Монолитная структура внутри сервиса, но с четким разделением на модули

2. Video Analyzer - Python (FastAPI)
Выбор стека: FastAPI + OpenCV + TensorRT + Redis Pub/Sub

    Обоснование:

    - Высокая производительность: FastAPI на asyncio, TensorRT для оптимизации инференса
    - Реальное время: Redis Pub/Sub для событий с задержкой <100мс
    - Простота развертывания: Docker контейнер с GPU поддержкой
    - Ключевой паттерн: Конвейер обработки с параллельными стадиями

3. Synchronization Service - Java (Quarkus)
Выбор стека: Quarkus + Kafka Client + MQTT Client

    Обоснование:

    - Низкое потребление памяти: Критично для облачного развертывания
    - Быстрый старт: Необходимо для serverless-развертывания в будущем
    - Нативная поддержка Kafka: Отличная интеграция с существующей инфраструктурой
    - Паттерн: Strategy Pattern для разных типов синхронизации

### Технические решения уровня кода
**AI Inference Engine:**
    
- Тензорная оптимизация: TensorRT для 5-10x ускорения инференса
- Кэширование результатов: Redis для похожих кадров (тени, статичные сцены)
- Пакетная обработка: Batch processing для увеличения throughput GPU

**Синхронизация данных:**

- Конфликт-резолвер: Версионность данных + лог изменений
- Приоритетные очереди: Сначала события тревог, потом телеметрия
- Режим оффлайн: Локальное хранение с маркировкой "ожидает синхронизации"

**Компромиссы**
- Разнородность стеков: Python (AI), Java (синхронизация), Go (gateway).

Плюс: Лучший инструмент для каждой задачи

Минус: Сложнее найти fullstack разработчиков, нужны эксперты в каждом стеке

- Сложность Video Analyzer: Много зависимостей (CUDA, TensorRT, OpenCV)

Плюс: Максимальная производительность

Минус: Сложность развертывания и обновления

- Дублирование логики: Некоторый анализ поведения делается и на ферме (реальное время), и в облаке (глубокий анализ)

Плюс: Обеспечение автономности фермы

Минус: Необходимость синхронизации логики и моделей

**Риски и стратегии смягчения**
- Риск: Падение производительности Video Analyzer при росте количества камер

Стратегия: Мониторинг FPS и latency, автоматическое уменьшение разрешения при нагрузке

- Риск: Расхождение данных при конфликтующих обновлениях

Стратегия: Подробное логирование всех изменений, возможность ручного разрешения конфликтов через интерфейс

- Риск: Сложность отладки распределенного конвейера обработки видео

Стратегия: Визуализация потока обработки, метрики на каждом этапе, сэмплирование кадров для анализа